---
title: "weighted PE + Outcome - model 26"
format: html
editor: visual
---

## Model 5

In this model, anxiety/mood on trial $t$ is calculated by adding the intercept $\beta_0$ (the value of anxiety/mood when PE and weighted sum of outcomes on that trial are set to 0), PE, and weighted sum of outcomes on trial $t$.

The explicit expectation is the one reported by the participants.

$$
A_{it} = \beta_{0i} + \beta_{1i} \cdot PE_t+ \beta_{2i} \cdot \sum_{j=1}^{t} \gamma_i^{t - j} \cdot O_j 
$$

$$
M_{it} = \beta_{0i} + \beta_{1i} \cdot PE_t+ \beta_{2i} \cdot \sum_{j=1}^{t} \gamma_i^{t - j} \cdot O_j 
$$ $$
PE_t = O_t - Ee_t 
$$

```{r}
########################################## For Anxiety ########################################
library(rstan)
library(dplyr)
library(ggplot2)
library(here)
library(tidyr)
library(loo)
library(matrixStats)

data <- read.csv(here("Data","Extracted_data","Merged Data - all groups", "surprise_task_merged_data.csv"))
  
data[, c("Response_fdbk", "Response_pred", "Response_H", "Response_Ax", "Response_SubjPE")] <- scale(data[, c("Response_fdbk", "Response_pred", "Response_H", "Response_Ax", "Response_SubjPE")])


N <- length(unique(data$Random_ID))  # Number of participants
T <- 48  # Trials per participant

stan_data <- list(
  N = N,
  T = T,
  Tsubj = rep(48, N),
  Response_fdbk = matrix(data$Response_fdbk, nrow = N, ncol = T, byrow = TRUE),
  Response_Ax = matrix(data$Response_Ax, nrow = N, ncol = T, byrow = TRUE),
  Response_SubjPE = matrix(data$Response_SubjPE, nrow = N, ncol = T, byrow = TRUE)
)


# Stan Model
weighted_outcome_PE_anx <- "
data {
  int<lower=1> N; // Number of Participants
  int<lower=1> T; // Trials per subject
  int<lower=1, upper=T> Tsubj[N]; 
  array[N, T] real Response_SubjPE;  // Reported expectation
  array[N, T] real Response_Ax;
  array[N, T] real Response_fdbk;
}
transformed data {
}
parameters {
  real intercept;
  real w1_mu;
  real w2_mu;
  real gam_mu;
  real sig_mu;
  
  real<lower=0> sigma_w0;
  vector<lower=0>[4] sigma;
  vector[N] w0_pr;
  vector[N] w1_pr;
  vector[N] w2_pr;
  vector[N] gam_pr;
  vector[N] sig_pr;
}
transformed parameters {
  vector[N] w0;
  vector[N] w1;
  vector[N] w2;
  vector<lower=0, upper=1>[N] gam;
  vector<lower=0>[N] sig;
  
  w0 = intercept + sigma_w0 * w0_pr;
  w1 = w1_mu + sigma[1] * w1_pr;
  w2 = w2_mu + sigma[2] * w2_pr;

  for (i in 1:N) {
    gam[i] = Phi_approx(gam_mu + sigma[3] * gam_pr[i]);
  }
  sig = exp(sig_mu + sigma[4] * sig_pr);
}
model {
   intercept  ~ normal(0, 0.5);
  w1_mu  ~ normal(0, 0.5);
  w2_mu  ~ normal(0, 0.5);
  gam_mu ~ normal(0, 0.5);
  sig_mu ~ normal(0, 0.5);
  
  sigma_w0 ~ normal(0, 1);
  sigma ~ normal(0, 0.1);

  // Individual parameters 
  w0_pr  ~ normal(0, 1.0);
  w1_pr  ~ normal(0, 1.0);
  w2_pr  ~ normal(0, 1.0);
  gam_pr ~ normal(0, 1.0);
  sig_pr ~ normal(0, 1.0);

  for (i in 1:N) {
    real outcome_sum = 0;

    for (t in 1:Tsubj[i]) {
      Response_Ax[i, t] ~ normal(w0[i] + w1[i] * outcome_sum + w2[i] * Response_SubjPE[i, t], sig[i]);

      outcome_sum += Response_fdbk[i, t];

      outcome_sum *= gam[i];
    }
  }
}
generated quantities {
  real mu_w0;
  real mu_w1;
  real mu_w2;
  real<lower=0, upper=1> mu_gam;
  real<lower=0> mu_sig;
  
  real log_lik[N];

  // For posterior predictive check
  real y_pred[N, T];
  
  // Set all posterior predictions to 0 (avoids NULL values)
  for (i in 1:N) {
    for (t in 1:T) {
      y_pred[i, t] = -1;
    }
  }

  mu_w0    = intercept;
  mu_w1    = w1_mu;
  mu_w2    = w2_mu;
  mu_gam   = Phi_approx(gam_mu);
  mu_sig   = exp(sig_mu);
  
  { // local section, this saves time and space
  for (i in 1:N) {
    real outcome_sum = 0;
    log_lik[i] = 0;

    for (t in 1:Tsubj[i]) {
      log_lik[i] += normal_lpdf(Response_Ax[i, t] | w0[i] + w1[i] * outcome_sum + w2[i] * Response_SubjPE[i, t], sig[i]);
      y_pred[i, t] = normal_rng(w0[i] + w1[i] * outcome_sum + w2[i] * Response_SubjPE[i, t], sig[i]);

      outcome_sum += Response_fdbk[i, t];

      outcome_sum *= gam[i];
    }
  }
  }
}
"
```

```{r}

# Compile and Fit the Model
weighted_outcome_PE_anx_fit <- stan(model_code = weighted_outcome_PE_anx, data = stan_data, iter = 4000, warmup = 2000, chains = 4, seed = 123, cores = 4, control = list(adapt_delta = 0.95,
  max_treedepth = 10))

# Print results
print(weighted_outcome_PE_anx_fit)

# Save the model output as an .rds file
saveRDS(weighted_outcome_PE_anx_fit, file = "weighted_outcome_PE_anx_fit.rds")
```

```{r}
rm(list = ls())

########################################## For Mood ########################################
library(rstan)
library(dplyr)
library(ggplot2)

# Load Data
data <- read.csv("/Users/elenabagdades/Library/CloudStorage/OneDrive-UniversityCollegeLondon/Desktop/GitHub/aim_lab_1/Surprise_task_data_analysis/surprise_task_merged_data.csv")
  
data[, c("Response_fdbk", "Response_pred", "Response_H", "Response_Ax", "Response_SubjPE")] <- scale(data[, c("Response_fdbk", "Response_pred", "Response_H", "Response_Ax", "Response_SubjPE")])

N <- length(unique(data$Random_ID))  # Number of participants
T <- 48  # Trials per participant

stan_data <- list(
  N = N,
  T = T,
  Tsubj = rep(48, N),
  Response_SubjPE = matrix(data$Response_SubjPE, nrow = N, ncol = T, byrow = TRUE),
  Response_H = matrix(data$Response_H, nrow = N, ncol = T, byrow = TRUE),
  Response_fdbk = matrix(data$Response_fdbk, nrow = N, ncol = T, byrow = TRUE)
)


# Stan Model

weighted_outcome_PE_mood <- "
data {
  int<lower=1> N; // Number of Participants
  int<lower=1> T; // Trials per subject
  int<lower=1, upper=T> Tsubj[N]; 
  array[N, T] real Response_SubjPE;  // Reported expectation
  array[N, T] real Response_H;
  array[N, T] real Response_fdbk;
}
transformed data {
}
parameters {
  real intercept;
  real w1_mu;
  real w2_mu;
  real gam_mu;
  real sig_mu;
  
  real<lower=0> sigma_w0;
  vector<lower=0>[4] sigma;
  vector[N] w0_pr;
  vector[N] w1_pr;
  vector[N] w2_pr;
  vector[N] gam_pr;
  vector[N] sig_pr;
}
transformed parameters {
  vector[N] w0;
  vector[N] w1;
  vector[N] w2;
  vector<lower=0, upper=1>[N] gam;
  vector<lower=0>[N] sig;
  
  w0 = intercept + sigma_w0 * w0_pr;
  w1 = w1_mu + sigma[1] * w1_pr;
  w2 = w2_mu + sigma[2] * w2_pr;

  for (i in 1:N) {
    gam[i] = Phi_approx(gam_mu + sigma[3] * gam_pr[i]);
  }
  sig = exp(sig_mu + sigma[4] * sig_pr);
}
model {
   intercept  ~ normal(0, 0.5);
  w1_mu  ~ normal(0, 0.5);
  w2_mu  ~ normal(0, 0.5);
  gam_mu ~ normal(0, 0.5);
  sig_mu ~ normal(0, 0.5);
  
  sigma_w0 ~ normal(0, 1);
  sigma ~ normal(0, 0.1);

  // Individual parameters 
  w0_pr  ~ normal(0, 1.0);
  w1_pr  ~ normal(0, 1.0);
  w2_pr  ~ normal(0, 1.0);
  gam_pr ~ normal(0, 1.0);
  sig_pr ~ normal(0, 1.0);


  for (i in 1:N) {
    real outcome_sum = 0;

    for (t in 1:Tsubj[i]) {
      Response_H[i, t] ~ normal(w0[i] + w1[i] * outcome_sum + w2[i] * Response_SubjPE[i, t], sig[i]);

      outcome_sum += Response_fdbk[i, t];

      outcome_sum *= gam[i];
    }
  }
}
generated quantities {
  real mu_w0;
  real mu_w1;
  real mu_w2;
  real<lower=0, upper=1> mu_gam;
  real<lower=0> mu_sig;
  
  real log_lik[N];

  // For posterior predictive check
  real y_pred[N, T];
  
  // Set all posterior predictions to 0 (avoids NULL values)
  for (i in 1:N) {
    for (t in 1:T) {
      y_pred[i, t] = -1;
    }
  }

  mu_w0    = intercept;
  mu_w1    = w1_mu;
  mu_w2    = w2_mu;
  mu_gam   = Phi_approx(gam_mu);
  mu_sig   = exp(sig_mu);
  
  { // local section, this saves time and space
  for (i in 1:N) {
    real outcome_sum = 0;
    log_lik[i] = 0;

    for (t in 1:Tsubj[i]) {
      log_lik[i] += normal_lpdf(Response_H[i, t] | w0[i] + w1[i] * outcome_sum + w2[i] * Response_SubjPE[i, t], sig[i]);
      y_pred[i, t] = normal_rng(w0[i] + w1[i] * outcome_sum + w2[i] * Response_SubjPE[i, t], sig[i]);

      outcome_sum += Response_fdbk[i, t];

      outcome_sum *= gam[i];
    }
  }
  }
}
"
```

```{r}

# Compile and Fit the Model
weighted_outcome_PE_mood_fit <- stan(model_code = weighted_outcome_PE_mood, data = stan_data, iter = 4000, warmup = 2000, chains = 4, seed = 123, cores = 4, control = list(adapt_delta = 0.95,
  max_treedepth = 10))

options(max.print = 9999)  # Set a higher limit

# Print results
print(weighted_outcome_PE_mood_fit)

# Save the model output as an .rds file
saveRDS(weighted_outcome_PE_mood_fit, file = "weighted_outcome_PE_mood_fit.rds")
```
